PROMPT-EJECUTOR (Replit) ‚Äî TheCookFlow API + Bridge + QA

Quiero que crees/actualices exactamente estos archivos y su contenido. Si no existen, cr√©alos. Si existen, reempl√°zalos por lo aqu√≠ indicado.

1) package.json (root)

{
  "name": "thecookflow-api",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "node server/index.js",
    "start": "node server/index.js",
    "qa:api": "node tools/qa/health-check.js"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1"
  }
}


2) .replit

run = "npm run dev"


3) .env.example

OPENAI_API_KEY=
PERPLEXITY_API_KEY=
PORT=3000
ALLOWED_ORIGINS=http://localhost:5173,https://app.thecookflow.com,https://thecookflow.com
UPLOAD_DIR=./uploads
BILLING_PROVIDER=play


4) server/index.js

import 'dotenv/config';
import fs from 'node:fs';
import path from 'node:path';
import express from 'express';
import morgan from 'morgan';
import helmet from 'helmet';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import multer from 'multer';
import { fileURLToPath } from 'node:url';
import { securityMiddleware } from './middleware/security.js';
import * as ai from './services/ai.js';
import * as billing from './services/billing.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PORT = process.env.PORT || 3000;
const UPLOAD_DIR = process.env.UPLOAD_DIR || path.join(__dirname, '..', 'uploads');
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

const app = express();

// --- CORS exacto ---
const allowed = (process.env.ALLOWED_ORIGINS || '').split(',').map(s => s.trim()).filter(Boolean);
app.use(cors({
  origin(origin, cb){
    if (!origin) return cb(null, true);              // permitir curl/postman
    if (allowed.includes(origin)) return cb(null, true);
    return cb(new Error('CORS: origin not allowed: '+origin));
  },
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type','Accept','x-utm-source','x-utm-medium','x-utm-campaign'],
  credentials: false
}));
app.options('*', (req,res)=>res.sendStatus(200));

// --- Seguridad base ---
app.use(helmet({
  contentSecurityPolicy: {
    useDefaults: true,
    directives: { "default-src": ["'self'", "https:"], "img-src": ["'self'","https:","data:","blob:"] }
  },
  referrerPolicy: { policy: "no-referrer" }
}));
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended:true, limit: '1mb' }));
app.use(morgan('tiny'));
app.use(securityMiddleware());

// --- Rate limits ---
const rlCommon = rateLimit({ windowMs: 15*60*1000, max: 100 });
const rlChef   = rateLimit({ windowMs: 15*60*1000, max: 30 });
app.use('/api/', rlCommon);

// --- Health ---
app.get('/api/health', (req,res)=> {
  res.json({ ok:true, ts: Date.now(), env: process.env.NODE_ENV || 'dev' });
});

// --- Chef IA ---
app.post('/api/chef', rlChef, async (req,res,next)=>{
  try{
    const { prompt, alergias = [], presupuesto, tiempo, imageUrl } = req.body || {};
    if (!prompt || typeof prompt !== 'string') return res.status(400).json({ error:'prompt requerido' });
    const result = await ai.generate({ prompt, alergias, presupuesto, tiempo, imageUrl });
    res.json({ result });
  }catch(err){ next(err); }
});

// --- Billing ---
app.get('/api/subscription-status', (req,res)=>{
  const { userId } = req.query;
  if(!userId) return res.status(400).json({ error:'userId requerido' });
  res.json(billing.getStatus(userId));
});

app.post('/api/billing/verify', async (req,res)=>{
  const { userId, purchaseToken } = req.body || {};
  if(!userId || !purchaseToken) return res.status(400).json({ error:'userId y purchaseToken requeridos' });
  const out = await billing.verifyPlay({ userId, purchaseToken });
  res.json(out);
});

// --- Upload im√°genes ---
const storage = multer.diskStorage({
  destination: (req, file, cb)=> cb(null, UPLOAD_DIR),
  filename: (req, file, cb)=> {
    const ext = path.extname(file.originalname).toLowerCase();
    const name = Date.now() + '-' + Math.random().toString(36).slice(2) + ext;
    cb(null, name);
  }
});
const upload = multer({
  storage,
  limits: { fileSize: 4 * 1024 * 1024 },
  fileFilter: (req,file,cb)=>{
    const ok = ['image/jpeg','image/png','image/webp'].includes(file.mimetype);
    cb(ok ? null : new Error('mimetype no permitido'), ok);
  }
});
app.post('/api/upload', upload.single('file'), (req,res)=>{
  const fname = req.file?.filename;
  if(!fname) return res.status(400).json({ error:'no file' });
  res.json({ imageUrl: `/uploads/${fname}` });
});
app.use('/uploads', express.static(UPLOAD_DIR, { etag:true, maxAge:'1h' }));

// --- Error handler ---
app.use((err, req, res, next)=>{
  const code = res.statusCode >= 400 ? res.statusCode : 500;
  res.status(code).json({ error: err.message || 'internal', code, path: req.path, ts: Date.now() });
});

app.listen(PORT, ()=> console.log(`[TCF] API listening on :${PORT}`));


5) server/middleware/security.js

export function securityMiddleware(){
  return function(req,res,next){
    // Sanitizado b√°sico de prompt si existe
    if (req.body && typeof req.body.prompt === 'string') {
      req.body.prompt = req.body.prompt.trim().slice(0, 2500);
    }
    next();
  };
}


6) server/services/ai.js

const USE_OPENAI = !!process.env.OPENAI_API_KEY;

// Stub simple; si pones la clave, aqu√≠ puedes integrar la SDK de OpenAI.
export async function generate({ prompt, alergias=[], presupuesto, tiempo, imageUrl }){
  if (!USE_OPENAI){
    return `üçΩÔ∏è Men√∫ sugerido (MOCK)
- T√≠tulo: Pasta r√°pida con verduras
- Ingredientes: pasta (180g), calabac√≠n, tomate, ajo, AOVE, sal
- Pasos: 1) Sofr√≠e ajo y verduras; 2) cuece pasta; 3) mezcla y ajusta sal.
- Sustituciones: calabac√≠n ‚Üí pimiento; pasta ‚Üí arroz
- Tiempo aprox: 20 min. Presupuesto orientativo: 3.5‚Ç¨.
${imageUrl ? `Basado en imagen: ${imageUrl}` : ''}`;
  }
  // TODO: Implementar llamada real a OpenAI con modelo y guardarrails.
  return `Resultado IA (placeholder) para: ${prompt}`;
}


7) server/services/billing.js

const PLANS = new Map(); // userId -> { active, plan, updatedAt }

export async function verifyPlay({ userId, purchaseToken }){
  const active = typeof purchaseToken === 'string' && purchaseToken.endsWith('OK');
  if (active) PLANS.set(userId, { active:true, plan:'pro', updatedAt: Date.now() });
  return { active, plan: active ? 'pro' : 'free' };
}
export function getStatus(userId){
  return PLANS.get(userId) || { active:false, plan:'free' };
}


8) public/tcf-bridge.js

// Incl√∫yelo en tu WebApp (o sirve este archivo est√°tico si conviene)
window.tcf = {
  getUserId(){
    if (window.Android?.getUserId) return window.Android.getUserId();
    return localStorage.getItem('uid') || (localStorage.setItem('uid', crypto.randomUUID()), localStorage.getItem('uid'));
  },
  async status(){
    const uid = this.getUserId();
    const r = await fetch(`/api/subscription-status?userId=${encodeURIComponent(uid)}`);
    return r.json();
  },
  openSubscription(){
    const uid = this.getUserId();
    if (window.Android?.openSubscription) return window.Android.openSubscription(uid);
    location.href = 'https://play.google.com/store/apps/details?id=com.thecookflow.app';
  },
  setPro(active){ if (window.Android?.setPro) window.Android.setPro(!!active); }
};

window.addEventListener('tcf:deeplink', async (e)=>{
  const {userId, token} = e.detail || {};
  if (!token) return;
  await fetch('/api/billing/verify', {
    method:'POST',
    headers:{'content-type':'application/json'},
    body: JSON.stringify({ userId, purchaseToken: token })
  });
  window.tcf.setPro(true);
});


9) tools/qa/health-check.js

const base = `http://localhost:${process.env.PORT || 3000}`;
async function check(path, opts){ 
  const r = await fetch(base+path, opts);
  const t = await r.text();
  try{ return { ok:r.ok, json: JSON.parse(t) }; } catch{ return { ok:r.ok, text:t }; }
}

(async ()=>{
  let fail = 0;

  const h = await check('/api/health');
  console.log('health:', h);
  if(!h.ok || !h.json?.ok) fail++;

  const v = await check('/api/billing/verify', {
    method:'POST',
    headers:{'content-type':'application/json'},
    body: JSON.stringify({ userId:'tester', purchaseToken:'abcOK' })
  });
  console.log('verify:', v);
  if(!v.ok || !v.json?.active) fail++;

  const s = await check('/api/subscription-status?userId=tester');
  console.log('status:', s);
  if(!s.ok || !s.json?.active) fail++;

  process.exit(fail ? 1 : 0);
})().catch(err=>{ console.error(err); process.exit(1); });


10) README.md (extracto con curl)

# TheCookFlow API (Replit)
## Comandos
- `npm i`
- `npm run dev`
- `npm run qa:api`

## cURL √∫tiles


curl http://localhost:3000/api/health

curl -XPOST http://localhost:3000/api/billing/verify
 -H "content-type: application/json" -d '{"userId":"u1","purchaseToken":"xyzOK"}'
curl "http://localhost:3000/api/subscription-status?userId=u1
"

11) .gitignore

node_modules
.env
uploads

‚èØÔ∏è Pasos de ejecuci√≥n en Replit

Secrets ‚Üí a√±ade:

ALLOWED_ORIGINS = https://app.thecookflow.com,https://thecookflow.com,http://localhost:5173

(opcional) OPENAI_API_KEY, UPLOAD_DIR=./uploads

Shell

npm i
npm run dev


QA

npm run qa:api
# o manual:
curl $REPLIT_URL/api/health

‚úÖ Validaci√≥n final (R11)

/api/health devuelve { ok:true }.

/api/billing/verify con token que termine en OK activa PRO.

/api/subscription-status?userId=<id> refleja el estado.

/api/upload acepta imagen <4MB y devuelve { imageUrl }.

Peticiones desde https://app.thecookflow.com funcionan (CORS OK).

public/tcf-bridge.js permite:

tcf.getUserId()

tcf.openSubscription() (en Android abre Billing)

tcf.setPro(true) para ocultar anuncios.