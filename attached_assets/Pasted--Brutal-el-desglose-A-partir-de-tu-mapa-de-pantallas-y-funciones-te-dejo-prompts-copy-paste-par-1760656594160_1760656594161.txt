¬°Brutal el desglose! üí™ A partir de tu mapa de pantallas y funciones, te dejo prompts copy-paste para Replit (Agent/Workspace) que crean la estructura de rutas, guards, contratos (Zod), control de freemium/premium, APIs y DB. Est√°n ordenados para que alguien sin experiencia pueda seguirlos paso a paso sin romper nada de lo que ya tienes.

Suposiciones m√≠nimas: monorepo o repo con webapp/ (React+Vite) y server/ (Node+Express). DB con PostgreSQL y Drizzle (puedes cambiar por Prisma si prefieres). Auth: OIDC Replit + JWT en backend.

üî∑ BLOQUE A ‚Äî FRONTEND (WebApp)

Rutas, guards, layout, paywall y bridge Android.

A1) Router + Lazy + Layouts

Objetivo: montar todas tus rutas p√∫blicas/privadas con lazy loading y un layout com√∫n.

PROMPT (pega en Replit):

Crea/actualiza en webapp:

1) Instala deps:
- react-router-dom
- zustand
- zod

2) Crea src/app/router.tsx con:
- Rutas p√∫blicas:
  /, /login, /register, /pricing, /help, /contact, /legal
  /demo/questionnaire, /demo/generator, /demo/skinchef
  /tour/1-onboarding, /tour/2-menu, /tour/3-recipe, /tour/4-shopping-list, /tour/5-paywall
- Rutas autenticadas:
  / (home user) => redirige a /dashboard si auth
  /dashboard
  /onboarding, /onboarding/result, /questionnaire
  /menu-generator, /menu-generated, /my-menus
  /saved-recipes, /recipe-library, /skinchef
  /fridge-vision, /savings
  /amazon-fresh
  /account, /admin
  /qa, /qa/smoke, /previews

- Crea <PublicLayout/> y <PrivateLayout/> con navegaci√≥n simple y footer.
- Implementa <RequireAuth/>: si no hay auth ‚Üí redirige a /login (o muestra modal login).
- Implementa <RequirePRO/>: si no PRO ‚Üí muestra <PaywallDialog/> y bloquea.
- Todos los screens como lazy(() => import('...')) con placeholders.

A2) Estado global + Auth + Plan FREE/PRO

Objetivo: tener user, plan y contador de IA en un store simple.

PROMPT:

En webapp/src/store/app.ts crea Zustand store con:
- user: { id, email? } | null
- plan: 'free' | 'pro'
- iaCountToday: number
- actions: setUser, setPlan, incIaCount, resetIaCountIfNewDay

Al cargar la app:
- Lee userId desde window.tcf.getUserId?.() o genera UUID en localStorage.
- Llama GET /api/subscription-status?userId=... y setPlan('pro'|'free').
- Si pro -> window.tcf.setPro(true); si free -> setPro(false).

A3) Paywall y l√≠mite Freemium

Objetivo: bloquear a 3 usos/d√≠a en FREE y abrir compra en Android.

PROMPT:

En webapp/src/components/PaywallDialog.tsx:
- Modal con copy PREMIUM ‚Ç¨1.99/mes + prueba 7 d√≠as
- Bot√≥n ‚ÄúSuscribirse‚Äù -> window.tcf.openSubscription()

En la pantalla /skinchef y /menu-generator:
- Antes de llamar /api/chef o /api/generate-menu:
  - Si plan==='free' && iaCountToday>=3 -> abre PaywallDialog.
  - Si no -> incIaCount() y sigue.

A4) Bridge Android + Deep Link

Objetivo: escuchar el evento de deep link y verificar en backend.

PROMPT:

Crea webapp/src/tcf-bridge.ts y c√°rgalo en main.tsx:
- Implementa window.addEventListener('tcf:deeplink', async (e) => {
    const { userId, token } = e.detail || {};
    POST /api/billing/verify { userId, purchaseToken: token }
    setPlan('pro'); window.tcf.setPro(true);
  });

- Exporta helpers getUserId(), status(), openSubscription(), setPro().

A5) Vistas ‚Äústub‚Äù (r√°pidas) para QA

Objetivo: colocar contenidos m√≠nimos para cada ruta y no romper el router.

PROMPT:

Genera archivos vac√≠os con un <div> t√≠tulo y TODO:
- Public: Landing, Login, Register, Pricing, Help, Contact, Legal, Demos, Tour
- Private: Dashboard, Onboarding(+result), Questionnaire, MenuGenerator(+generated), MyMenus, SavedRecipes, RecipeLibrary, SkinChef, FridgeVision, Savings, AmazonFresh, Account, Admin, QA, QA/Smoke, Previews

üî∂ BLOQUE B ‚Äî BACKEND (API)

Contratos Zod, controladores, seguridad, billing, visi√≥n nevera y QA.

B1) Zod Schemas + Validaci√≥n

Objetivo: tipar y validar todas las entradas.

PROMPT:

En server/schemas/index.js (o .ts si usas TS) con zod:
- Auth: loginSchema { email, password }, registerSchema { email, password, name? }
- Menu: generateMenuSchema { userId, personas:int, presupuesto:number, tiempo:number, alergias?:string[], preferencias?:string[] }
- Chef: chefSchema { userId, prompt, alergias?:string[], presupuesto?:number, tiempo?:number, imageUrl?:string }
- Vision: fridgeVisionSchema { userId, imageUrl }
- Billing: verifySchema { userId, purchaseToken }
- Amazon: cartSchema { userId, items:[{name, qty, unit}] }
- QA: smokeSchema { }

Exporta parseadores para usar en controladores (safeParse).

B2) Rutas y Controladores

Objetivo: cubrir todos tus endpoints con stubs funcionales.

PROMPT:

En server/index.js a√±ade routers (usa import por archivo):
- /api/health (GET)
- /api/auth/login (POST), /api/auth/register (POST)
- /api/generate-menu (POST)
- /api/chef (POST)  [rate-limit 30/15min]
- /api/fridge/vision (POST)  [usa /api/upload antes]
- /api/shopping-list (POST/GET)  [simple en memoria al principio]
- /api/recipes (GET/POST/PUT/DELETE)  [library + saved]
- /api/billing/verify (POST), /api/subscription-status (GET)
- /api/amazon/checkout (POST)  [redir URL mock]
- /api/upload (POST)  [multer image <4MB]
- /api/qa/smoke (GET)  [dev]

Crea controladores por archivo en server/controllers/*.js
- Cada uno valida con zod, llama servicios y devuelve JSON consistente {ok:true,data} o {ok:false,error}

B3) Servicios IA y Men√∫s

Objetivo: unificar generate-menu y chef con el mismo motor.

PROMPT:

En server/services/ai.js:
- export async function generateMenu(input) { ... } // usa OpenAI si hay clave, si no mocka men√∫ semanal (7x3)
- export async function chef(input) { ... }         // receta o respuesta conversacional
- export async function analyzeFridge(imageUrl) { return {items:[{name:'huevo',freshness:'ok'}], tips:[], budgetImpact:2.5}; } // mock

En /api/generate-menu -> validate(generateMenuSchema) -> ai.generateMenu
En /api/chef -> validate(chefSchema) -> ai.chef
En /api/fridge/vision -> validate(fridgeVisionSchema) -> ai.analyzeFridge

B4) Billing + Plan

Objetivo: mock Play Billing + estado plan unificado.

PROMPT:

En server/services/billing.js:
- Map PLANS (userId -> {active:boolean, plan:'free'|'pro', updatedAt:number})
- verifyPlay({userId,purchaseToken}) -> activo si token termina 'OK'; set Map
- getStatus(userId) -> Map.get(userId) || {active:false, plan:'free'}
- (futuro) webhook Google Play: crea /api/billing/webhook (POST) que actualice el Map

En /api/subscription-status -> devuelve getStatus(userId)
En /api/billing/verify -> verifyPlay

B5) Seguridad, CORS y l√≠mites

Objetivo: pol√≠ticas conservadoras y CORS exacto.

PROMPT:

- helmet con CSP: default-src 'self' https:, img-src 'self' https: data: blob:
- CORS: or√≠genes exactos (thecookflow.com, app.thecookflow.com, replit preview)
- Rate limit: 100/15min global, 30/15min /api/chef
- Sanitizar prompt: trim, max 2500 chars
- JSON body limit: 1mb
- Error handler JSON unificado

B6) QA Endpoints

Objetivo: panel de humo que te diga qu√© falla.

PROMPT:

/api/qa/smoke (GET) -> ejecuta internamente:
- GET /api/health,
- GET /api/subscription-status?userId=testpro,
- POST /api/generate-menu (payload m√≠nimo),
- POST /api/chef ("Dime una receta r√°pida"),
- Resumen {health:'ok', billing:'ok', menu:'ok', chef:'ok'} con tiempos

üü© BLOQUE C ‚Äî BASE DE DATOS (Drizzle + PostgreSQL)

Tablas alineadas con tus entidades.

C1) Drizzle setup

PROMPT:

A√±ade deps:
- drizzle-orm, pg, dotenv

Crea server/db/schema.ts con tablas:
- users: id(uuid, pk), email unique, created_at
- subscriptions: id, user_id fk, plan('free'|'pro'), active boolean, purchase_token, updated_at
- menu_plans: id, user_id, data(jsonb), created_at
- recipes: id, user_id?, title, data(jsonb), created_at
- shopping_lists: id, user_id, data(jsonb), created_at
- food_recognitions: id, user_id, image_url, result(jsonb), created_at
- recipe_library: id, title, data(jsonb), tags text[], created_at
- google_play_purchases: id, user_id, token, status, payload jsonb, created_at

Crea server/db/index.ts para conectar a PG con URL de env (DATABASE_URL).
Crea server/services/repo.ts con funciones CRUD b√°sicas para cada entidad.

C2) Persistir lo b√°sico (opcional en esta fase)

PROMPT:

- En POST /api/billing/verify -> guarda en subscriptions + google_play_purchases
- En POST /api/generate-menu -> guarda en menu_plans (si PRO) o local-only si FREE
- En POST /api/chef -> guarda √∫ltima consulta en recipes (si el usuario la ‚Äúguarda‚Äù)
- En /api/fridge/vision -> inserta en food_recognitions

üü¶ BLOQUE D ‚Äî QA & DEV EXPERIENCE
D1) QA UI

PROMPT:

En webapp crea /qa y /qa/smoke:
- UI con botones "Probar Health", "Probar Billing", "Probar Chef", "Probar Generate Menu"
- Cada bot√≥n llama al endpoint correspondiente y pinta resultado (verde/rojo)

D2) Scripts de humo

PROMPT:

En tools/qa/health-check.js:
- Llama a /api/health, /api/billing/verify (u:tester, token:abcOK), /api/subscription-status?userId=tester, /api/generate-menu (payload peque√±o)
- Sale con code 0 si todo ok
package.json: "qa:api": "node tools/qa/health-check.js"

üüß BLOQUE E ‚Äî ANDROID BRIDGE (recordatorio)

(ya lo tienes, pero lo enlazo con el frontend y backend por si alguien nuevo sigue la gu√≠a)

Claves:

window.tcf.getUserId() genera/lee el userId

window.tcf.openSubscription() abre Play Billing y tras comprar llama /api/billing/verify

Al convertir a PRO, la WebApp llama window.tcf.setPro(true) y se ocultan Ads en Android.

‚úÖ Checklist de aceptaci√≥n por pantalla

Landing (/): visible sin auth; CTA ‚Üí /pricing y /register

Login/Register: mock con Replit OIDC; guarda JWT y userId

Pricing: muestra tabla FREE vs PRO; bot√≥n abre tcf.openSubscription() (si Android)

Demo: cuestionario/generador/skinchef funcionan con l√≠mites de demo

Tour: 5 pasos con capturas y mensajes

Dashboard: estado plan, m√©tricas b√°sicas

Onboarding: guarda preferencias en localStorage (y enviar a backend si PRO)

Menu Generator: respeta l√≠mites FREE; guarda en /my-menus si PRO

Recipe Library: listado filtrable; guardar en /saved-recipes si PRO

SkinChef: chat funcional; 3 usos FREE/d√≠a; con imagen solo PRO

Fridge Vision: subida de imagen ‚Üí /api/upload ‚Üí IA analiza (mock)

Savings: requiere PRO (usa <RequirePRO/>)

Amazon Fresh: genera ‚Äúcarrito sugerido‚Äù con enlaces (mock)

Account: ver plan actual; bot√≥n ‚ÄúGestionar suscripci√≥n‚Äù

Admin: gated por rol (stub)

QA / QA/Smoke / Previews: pruebas r√°pidas en desarrollo

¬øC√≥mo lo ejecutas ahora?

Pega los prompts en este orden: A1 ‚Üí A2 ‚Üí A3 ‚Üí A4 ‚Üí A5 ‚Üí B1 ‚Üí B2 ‚Üí B3 ‚Üí B4 ‚Üí B5 ‚Üí B6 ‚Üí C1 ‚Üí (C2 opcional) ‚Üí D1 ‚Üí D2.

En Replit, a√±ade Secrets: DATABASE_URL (si usas PG), ALLOWED_ORIGINS, y los de IA si aplican.

npm i en server/ y webapp/ (o desde ra√≠z si monorepo).

Arranca: npm run dev (server) y npm run dev (webapp).

Abre /qa y /qa/smoke para validar humo.